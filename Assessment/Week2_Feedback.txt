Starting weekly assessment for Tom, Week2

Current Marks = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 99.92 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, .git, Week3

Found the following files in parent directory: README.txt, CMEEGuidebook.pdf, .gitignore, Guidebook_2017_Silwood.pdf

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE 2017-2018 Coursework Repository
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox

Found the following files: readme.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: readme.txt

Printing contents of readme.txt:
**********************************************************************
Week 2
├── Code
│   ├── align_seqs.py 	#DNA Sequence Alignment scoring using matched. Edited to accept .csv input.
│   ├── basic_csv.py    #csv importing; reading and writing
│   ├── basic_io.py	#file input and output
│   ├── boilerplate.py	#boilerplate test. Run from bash with "python boilerplate.py"!
│   ├── cfexcercises.py #Testing importing of 'foo' functions
│   ├── control_flow.py #Demonstrating importing of functions
│   ├── debugme.py	#Demonstrating bugs in code
│   ├── dictionary.py	#Python script to convert list of tuples -> dictionary, wherein the key starts as row[1]
│   ├── lc1.py		#Using LCs and Loops to create specific data lists from tuples
│   ├── lc2.py		#Using LCs and Loops to filter data from tuples
│   ├── loops.py	#Demons. loops
│   ├── oaks.py		#Demons. lcs
│   ├── profileme.py	#Demons local functions
│   ├── PythonPrac1_Checklist.txt #Checklist notes to self
│   ├── PythonPrac2_Checklist.txt #Checklist notes to self
│   ├── Readme.txt #This document!
│   ├── scope.py	#Demons. global and local functions
│   ├── sysargv.py	#Demons. the use of sys in importing
│   ├── test_oaks.py	#Example of using doctest to debug specific string arguments	
│   ├── timeitme.py	#Demons. code for timing functions
│   ├── ToDo.txt	#Checklist notes to self
│   ├── tuple.py	#Converts Tuple of Tuples into Flat list of strings from within tuples
│   ├── using_name.py	#Demonstrating way to change output depending on import status
├── Data
├── Readme.txt
├── Sandbox
│   ├── testout.txt
│   ├── testp.p
│   ├── test.txt
│   └── untitled
└── testcsv.csv


**********************************************************************

Results directory missing!

Found 24 code files: lc2.py, boilerplate.py, PythonPrac1_Checklist.txt, basic_csv.py, timeitme.py, profileme.py, test_oaks.py, Readme.txt, dictionary.py, debugme.py, scope.py, tuple.py, basic_io.py, lc1.py, oaks.py, PythonPrac2_Checklist.txt, loops.py, using_name.py, align_seqs.py, sysargv.py, align_seqs_fasta.py, control_flow.py, cfexcercises.py, ToDo.txt

Found the following extra files: .csv
0.5 pt deducted per extra file

Current Marks = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""Using LCs and Loops to filter data from tuples"""
	
__author__ = 'Tom Davy (t.davy17@ic.ac.uk)'
__version__= '0.0.1'


# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

rainfall_lc_high = set(rainfall for rainfall in rainfall if rainfall[1] > 100.0)
print rainfall_lc_high
 
#set = hashing, helping with computational speed. This line is searching for instances
# where rainfall in mm was over 100. In context of this data matrix, this is searching
# the 2nd column (rainfall[1]). 
 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

rainfall_lc_low_month = set(rainfall[0] for rainfall in rainfall if rainfall[1] < 50.0)
print rainfall_lc_low_month
 
# (3) Now do (1) using conventional loops (you can choose to do 
# this before 1!). 

rainfall_loop_high = set()
for mm in rainfall:
	if mm[1] > 100:
		rainfall_loop_high.add(mm)
print rainfall_loop_high


rainfall_loop_low = set()
for mm in rainfall:
	if mm[1] < 50.0:
		rainfall_loop_low.add(mm[0])
print rainfall_loop_low


# ANNOTATE WHAT EVERY BLOOK IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set([('JAN', 111.4), ('AUG', 140.2), ('DEC', 142.2), ('FEB', 126.1), ('NOV', 128.4)])
set(['MAR', 'SEP'])
set([('JAN', 111.4), ('AUG', 140.2), ('DEC', 142.2), ('FEB', 126.1), ('NOV', 128.4)])
set(['MAR', 'SEP'])

**********************************************************************

Code ran without errors

Time consumed = 0.03298s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python  #The Shebang - Tells computer where to look for python executable. Using /env prevents failure to run should python be stored elsewhere.

"""Description of this program
	you can use several lines"""  #The Docstring - describes the operation of script or function/module within. Consdiered part of running code, hence accessible at run time. Good idea to keep as it provides info for me and users at runtime. Can access in a script by importing the function and then typing help(my_func) in the python/ipython shell.
	
__author___ = 'Tom Davy (t.davy17@imperial.ac.uk)'
__version__ = '0.0.1' #Internal Variables; "__" signal "internal" variables (never name your variables such)

# imports
import sys # module to interface our program with the operation system

#constants can go here


#functions can go here
def main(argv): #def indicates start of python function. Hence subsequent lines MUST be indented. "def main(argv): directs python intepreter to pass the argument variables ot main function.
		print 'This is a boilerplate' # NOTE: indented using two tabs or 4 spaces return 0
		
if (__name__ == "__main__"): #makes sure the main function is called from commandline
		status = main(sys.argv) #"Argument Variable". --argv is a var. that holds arguments you pass to python script. sys.argv is an object created by python using the sys module, containing names of the argument variables in current script. 
		sys.exit(status) #Control Statement - Way to exit in "a dignified and abrupt manner
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02270s

======================================================================
Inspecting script file PythonPrac1_Checklist.txt...

File contents are:
**********************************************************************
 ##  5.10.2 ##
1. Modify cfexercises.oy to make a module like control_flow.py.
2. Complete lc1.py;lc2.py;dictionary.py;tuple.py
**********************************************************************

Testing PythonPrac1_Checklist.txt...

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
import csv

# Read a file containing:
# "Species","Infraorder","Family","Distribution","Body mass male (Kg)"
f = open ('../Sandbox/testcsv.csv','rb')

csvread = csv.reader (f)
temp = []
for row in csvreader (f)
	temp.appennd(tuple(row))
	print row
	print "The species is", row[0]

f.close ()

# write a file containing only species name and Body mass
f = open('../Sandbox/testcsv.csv','rb')
g = open('../Sandbox/bodymass.csv','wb')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
	print row
	csvwrite.writerow([row[0], row[4]])
	
f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 98.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
  File "basic_csv.py", line 9
    for row in csvreader (f)
                           ^
SyntaxError: invalid syntax

======================================================================
Inspecting script file timeitme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python


##############################
# range vs .xrange.
##############################
import time
import timeit

def a_not_useful_function():
	y = 0
	for i in range (100000):
		y = y + i
	return 0
	
def a_less_useless_function():
	y = 0
	for i in xrange(1000000):
		y = y + i
	return 0
	
#One approach is to time it like this
start = time.time()
a_not_useful_function()
print "a_not_useful_function takes %f s to run." % (time.time() - start)
start = time.time()
a_less_useless_function()
print "a_less_useless_function takes %f s to run." % (time.time() - start)

#But you'll notice that if you run it multiple times, the time taken changes a bit.
#So instead, you can also run:
#	%timeit a_not_useful_function()
#	%timeit a_less_useless_function()
# in iPython

##############################################
# for loops vs. list comprehensions.
##############################################

my_list = range(1000)

def my_squares_loops(x):
	out = []
	for i in x:
		out.append(i ** 2)
	return out

def my_squares_lc(x):
	out = [i ** 2 for i in x]
	return out
	
#%timeit my_squares_loop(my_list)
#%timeit my_squares_lc(my_list)

#############################################
# for loops vs. join method
#############################################

import string
my_letters = list(string.ascii_lowercase)

def my_join_loop(l):
	out = ''
	for letter in l:
		out += letter
	return out
	
def my_join_method(l):
	out = ''.join(1)
	return out
	
#%timeit(my_join_loop(my_letters))
#%timeit(my_join_method(my_letters))


###########################################
# Oh dear
###########################################

def getting_silly_pi():
	y = 0
	for i in xrange(100000):
		y = y + i
	return 0
	
def getting_silly_pii():
	y = 0
	for i in xrange(100000):
		y += i
	return 0

#%timeit(getting_silly_pi())
#%timeit(getting_silly_pii(()

		
**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 97.5

Output (only first 500 characters): 

**********************************************************************
a_not_useful_function takes 0.007022 s to run.
a_less_useless_function takes 0.038536 s to run.

**********************************************************************

Code ran without errors

Time consumed = 0.06609s

======================================================================
Inspecting script file profileme.py...

File contents are:
**********************************************************************
def a_useless_function(x):
	y = 0
	# eight zeroes!
	for i in xrange(100000000):
		y = y + i
	return 0

def a_less_useless_function(x):
	y = 0
	# five zeroes!
	for i in xrange(100000):
		y = y + i
	return 0

def some_function(x):
	print x
	a_useless_function(x)
	a_less_useless_function(x)
	return 0

some_function(1000)
**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 96.5

Output (only first 500 characters): 

**********************************************************************
1000

**********************************************************************

Code ran without errors

Time consumed = 2.86395s

======================================================================
Inspecting script file test_oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""Example of using doctest to debug specific string arguments"""

__author__ = 'Tom Davy (t.davy17@ic.ac.uk)'
__version__= '0.0.1'

import csv
import sys
import doctest

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus '
        >>> is_an_oak('quercus ')
        True
    
		Returns True if name is starts with 'quercus '
		>>> is_an_oak('quercus')
		False
		
		Returns True if name is starts with 'quercus '
		>>> is_an_oak('oak ')
		False
		
    """
    return name.lower().startswith('quercus ')
    
print(is_an_oak.__doc__)

def main(argv): 
    f = open('../Data/TestOaksData.csv','rb')
    g = open('../Data/JustOaksData.csv','wb')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        print row
        print "The genus is", row[0]
        if is_an_oak(row[0]):
            print row[0]
            print 'FOUND AN OAK!'
            print " "
            csvwrite.writerow([row[0], row[1]])    
    
    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()
**********************************************************************

Testing test_oaks.py...

test_oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
 Returns True if name is starts with 'quercus '
        >>> is_an_oak('quercus ')
        True
    
		Returns True if name is starts with 'quercus '
		>>> is_an_oak('quercus')
		False
		
		Returns True if name is starts with 'quercus '
		>>> is_an_oak('oak ')
		False
		
    

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "test_oaks.py", line 49, in <module>
    status = main(sys.argv)
  File "test_oaks.py", line 32, in main
    f = open('../Data/TestOaksData.csv','rb')
IOError: [Errno 2] No such file or directory: '../Data/TestOaksData.csv'

======================================================================
Inspecting script file Readme.txt...

File contents are:
**********************************************************************
locals will call local variables

**********************************************************************

Testing Readme.txt...

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""Python script to convert list of tuples -> dictionary,
	wherein the key starts as row[1]"""
	
__author__ = 'Tom Davy (t.davy17@ic.ac.uk)'
__version__= '0.0.1'


taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]


# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS

# Write your script here:


#~#~# so Key = Order names. Value = Species #~#~#
#Split Tuple

taxa_dic = {}

for row in (taxa):
	if row[1] not in taxa_dic:
		taxa_dic[row[1]] = set()
	taxa_dic[row[1]].add(row[0])
	#~ print taxa_dic

for key in taxa_dic:
	print key, taxa_dic[key]
		#calls for keys in dictionary

# index by key to add values to dictionary taxa_dic{}
	






#~ taxa_dic = dict(taxa)
#~ print taxa_dic
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Rodentia set(['Peromyscus crinitus', 'Mus domesticus', 'Gerbillus henleyi', 'Cleithrionomys rutilus'])
Afrosoricida set(['Microgale dobsoni', 'Microgale talazaci'])
Chiroptera set(['Myotis lucifugus'])
Carnivora set(['Arctocephalus gazella', 'Lyacon pictus', 'Canis lupus'])

**********************************************************************

Code ran without errors

Time consumed = 0.01105s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
def createabug(x):
	y =  x**4
	z = 0.
	y = y/z
	return y
	
createabug(25)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 95.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "debugme.py", line 7, in <module>
    createabug(25)
  File "debugme.py", line 4, in createabug
    y = y/z
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************

#!/usr/bin/env python


## Try this first

_a_global = 10

def a_function():
	_a_global = 5
	_a_local = 4
	print "Inside the function, the value is ", _a_global
	print "Inside the function, the value is ", _a_local
	return None
	
a_function()
print "Outside the fucntion, the value is ", _a_global


## Now try this

_a_global = 10
def a_function():
		global _a_global
		_a_global = 5
		_a_local = 4
		print "Inside the function, the value is ", _a_global
		print "Inside the function, the value is ", _a_local
		return None
	
a_function()
print "Outside the function, the value is ", _a_global
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 94.5

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value is  5
Inside the function, the value is  4
Outside the fucntion, the value is  10
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function, the value is  5

**********************************************************************

Code ran without errors

Time consumed = 0.01187s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""Converts Tuple of Tuples into Flat list of strings from
	within tuples"""
	
__author__ = 'Tom Davy (t.davy17@imperial.ac.uk)'
__version__ = '0.0.1'


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line for each species
# Hints: use the "print" command! You can use list comprehensions!


flat = [word for tup in birds for word in tup]

# 'flat' is a list comprehension that creates a list of all 
# all strings/'word's in the tuples/'tup's in birds. This can then
# output as a flat unnested structure. Using 'print flat' 
# will concatenate the ordered list into a block of text instead.

flat


# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.01092s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
##################
# FILE INPUT
##################
# Open a file for reading
f = open('../Sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
	print line, # the "," prevents adding a new line
	
#close the file
f.close()

# Same example, skip blank lines
f = open ('../Sandbox/test.txt', 'r')
for line in f:
	if len(line.strip())>0:
		print line,

f.close ()

#################
# FILE OUTPUT
#################
# Save the elements of a list to the file
list_to_save = range (100)

f = open ('../Sandbox/testout.txt','w')
for i in list_to_save:
	f.write(str(i) + '\n') ## Add a new line at the end
	
f.close()

################
# STORING OBJECTS
################
#To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../Sandbox/testp.p','wb') ##note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open ('../Sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print another_dictionary
**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 93.5

Output (only first 500 characters): 

**********************************************************************
##################
# FILE INPUT
##################
# Open a file for reading
f = open('../Sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
	print line, # the "," prevents adding a new line
	
#close the file
f.close()

# Same example, skip blank lines
f = open ('../Sandbox/test.txt', 'r')
for line in f:
	if len(line.strip())>0:
		print line,

f.close ()

#################
# FILE OUTPUT
#################
# Save the elemtns of 
**********************************************************************

Code ran without errors

Time consumed = 0.01458s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""Using LCs and Loops to create specific data lists from tuples"""
	
__author__ = 'Tom Davy (t.davy17@ic.ac.uk)'
__version__= '0.0.1'



birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

#########################

birds_species_lc = set ([species[0] for species in birds])
print birds_species_lc

birds_cnames_lc = set ([cnames[1] for cnames in birds])
print birds_cnames_lc

birds_xmass_lc = set ([xmass[2] for xmass in birds])
print birds_xmass_lc

###WHEREIN
#x[y] functions as x[i], where i is the position in each tuple string to add from

########################
# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

birds_species_loops = set ()
for species in birds:
	birds_species_loops.add(species[0])
print birds_species_loops

birds_cnames_loops = set ()
for cnames in birds:
	birds_cnames_loops.add(cnames[1])
print birds_cnames_loops

birds_xmass_loops = set ()
for xmass in birds:
	birds_xmass_loops.add(xmass[2])
print birds_xmass_loops

#WHEREIN:
  #"x_Y_loops = set ()" defines a new function
  #"x_y_loops.add(y[z]) adds the arbitarily chosen y'th element from each tuple in given data to the loops function.
  
 


#######################
# ANNOTATE WHAT EVERY BLOCK OR, IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Junco hyemalis', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Tachycineata bicolor', 'Delichon urbica'])
set(['Savannah sparrow', 'House martin', 'Dark-eyed junco', 'Yellow-eyed junco', 'Tree swallow'])
set([19.5, 20.2, 19, 18.7, 19.6])
set(['Junco hyemalis', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Tachycineata bicolor', 'Delichon urbica'])
set(['Savannah sparrow', 'House martin', 'Dark-eyed junco', 'Yellow-eyed junco', 'Tree swallow'])
set([19.5, 20.2, 19, 18.7, 19.6])

**********************************************************************

Code ran without errors

Time consumed = 0.01243s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
## Let's find just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
		 'Fraxinus excelsior',
		 'Pinus sylverstris',
		 'Quercus cerris',
		 'Quercus pertraea'
	   ]

def is_an_oak(name):
	return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
	if is_an_oak(species):
		oaks_loops.add(species)
print oaks_loops

##Using list comprehensions
oaks_lc = set ([species for species in taxa if is_an_oak(species)])
print oaks_lc 


##Get names in UPPER CASE using for loops
oaks_loops = set ()
for species in taxa:
		if is_an_oak(species):
			oaks_loops.add(species.upper())
print oaks_loops

##Get names in UPPER CASE using list comprehensions
oaks_lc = set ([species.upper() for species in taxa if is_an_oak(species)])
print oaks_lc
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 92.5

Output (only first 500 characters): 

**********************************************************************
set(['Quercus pertraea', 'Quercus robur', 'Quercus cerris'])
set(['Quercus pertraea', 'Quercus robur', 'Quercus cerris'])
set(['QUERCUS PERTRAEA', 'QUERCUS ROBUR', 'QUERCUS CERRIS'])
set(['QUERCUS PERTRAEA', 'QUERCUS ROBUR', 'QUERCUS CERRIS'])

**********************************************************************

Code ran without errors

Time consumed = 0.01237s

======================================================================
Inspecting script file PythonPrac2_Checklist.txt...

File contents are:
**********************************************************************
 ## 5.12.1 ##
1) Align DNA Sequences
  To position shorter string within all possible positions of longer string
  To Score each position; number of perfectly matche bases over number of bases attempted
  
**********************************************************************

Testing PythonPrac2_Checklist.txt...

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
# for loops in Python
for i in range(5):
	print i
		
my_list = [0, 2, "geroninomo!", 3.0, True, False]
for k in my_list:
	print k
		
total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
	print total + s
		
# while loops in Python
z = 0
while z < 100:
	z = z + 1
	print (z)
	
b = True
while b:
	print "GERONIMO! infinite loop! ctrl+c to stop!"
# ctrl + c to stop!
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 91.5

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geroninomo!
3.0
True
False
0
1
11
111
1111
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl
**********************************************************************

Code ran without errors

Time consumed = 10.38770s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!usr/bin/python
# Filename: using_name.py
if __name__ == "__main__":
	print 'This program is being run by itself'
else:
	print 'I am being imported from another module'
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 90.5

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.01121s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""DNA Sequence Alignment Function"""
__author__ = 'Tom Davy'
__version__= '0.0.1'

import sys
import csv

# These are the two sequences to match
seq = csv.reader(open("../Data/align_seq.fasta", "rb"))

#TO DO: Use RegExp to read fasta files instead of csv files!
# use f.readline() ?

for row in seq:
	seq1 = row[0]
	seq2 = row[1]
	
##Assuming correct csv file format, row 0 and row 1 correspond
# to DNA sequences. This could do with a test for correct data entry
# for example, a regex to see if input string does not contain anything
# other than ATGC, or a fasta file name.
	

# assign the longest sequence s1, and the shortest to s2
# l1 is the length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint
def calculate_score(s1, s2, l1, l2, startpoint):
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignement
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # build some formatted output
    print "." * startpoint + matched           
    print "." * startpoint + s2
    print s1
    print score 
    print ""

    return score

calculate_score(s1, s2, l1, l2, 0)
calculate_score(s1, s2, l1, l2, 1)
calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1

for i in range(l1):
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2
        my_best_score = z


#~ out = open('../Data/align_seq_scores.txt', "wb")
#~ csvwrite = csv.writer(out)	
#~ for out:


print my_best_align
print s1
print "Best score:", my_best_score

s = str(my_best_align)
t = str(s1)
u = str(my_best_score)

#assigning outputs to variables for easy output. Maybe a better
#way than this


with open("../Data/align_seq_scores.txt", "wb") as text_file:
	text_file.write(s)
	text_file.write("\n")
	text_file.write(t)
	text_file.write("\n")
	text_file.write("Best score:")
	text_file.write(u)
	
# using open avoids having to use close and writes faster. "\n" denotes newlines
# for better formatting.



#~ out.close()
#~ seq.close()


#~ def main(argv):
	#~ print ('my_best align', s1, "Best score:", my_best_score)
#~ sys.exit(status)
		
#~ if (__name__ == "__main__"):
	#~ status = main(sys.argv)
	#~ sys.exit(status)		
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1

...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1

....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1

.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4

.......-*-*-***-
.......CAA
**********************************************************************

Code ran without errors

Time consumed = 0.01489s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
import sys
print "This is the name of the script: ", sys.argv[0]
print "Number of arguments: ", len(sys.argv)
print "The arguments are: ", str(sys.argv)	
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 89.5

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.01268s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

"""DNA Sequence Alignment Function"""
__author__ = 'Tom Davy'
__version__= '0.0.1'

import sys
import csv

# These are the two sequences to match
seq1= (open(raw_input('Enter Sequence 1 File Path: ')

#TO DO: Use RegExp to read fasta files instead of csv files!
# use f.readline() ?

for row in seq:
	seq1 = row[0]
	seq2 = row[1]
	
##Assuming correct csv file format, row 0 and row 1 correspond
# to DNA sequences. This could do with a test for correct data entry
# for example, a regex to see if input string does not contain anything
# other than ATGC, or a fasta file name.
	

# assign the longest sequence s1, and the shortest to s2
# l1 is the length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint
def calculate_score(s1, s2, l1, l2, startpoint):
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignement
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # build some formatted output
    print "." * startpoint + matched           
    print "." * startpoint + s2
    print s1
    print score 
    print ""

    return score

calculate_score(s1, s2, l1, l2, 0)
calculate_score(s1, s2, l1, l2, 1)
calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1

for i in range(l1):
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2
        my_best_score = z


#~ out = open('../Data/align_seq_scores.txt', "wb")
#~ csvwrite = csv.writer(out)	
#~ for out:


print my_best_align
print s1
print "Best score:", my_best_score

s = str(my_best_align)
t = str(s1)
u = str(my_best_score)

#assigning outputs to variables for easy output. Maybe a better
#way than this


with open("../Data/align_seq_scores.txt", "wb") as text_file:
	text_file.write(s)
	text_file.write("\n")
	text_file.write(t)
	text_file.write("\n")
	text_file.write("Best score:")
	text_file.write(u)
	
# using open avoids having to use close and writes faster. "\n" denotes newlines
# for better formatting.



#~ out.close()
seq.close()
csv.reader.close()

#~ def main(argv):
	#~ print ('my_best align', s1, "Best score:", my_best_score)
#~ sys.exit(status)
		
#~ if (__name__ == "__main__"):
	#~ status = main(sys.argv)
	#~ sys.exit(status)		
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
  File "align_seqs_fasta.py", line 16
    for row in seq:
                  ^
SyntaxError: invalid syntax

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python  #The Shebang - Tells computer where to look for python executable. Using /env prevents failure to run should python be stored elsewhere.

"""Some functions exemplifying the use of control statements"""  #The Docstring - describes the operation of script or function/module within. Consdiered part of running code, hence accessible at run time. Good idea to keep as it provides info for me and users at runtime. Can access in a script by importing the function and then typing help(my_func) in the python/ipython shell.
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.	

__author___ = 'Tom Davy (t.davy17@imperial.ac.uk)'
__version__ = '0.0.1' #Internal Variables; "__" signal "internal" variables (never name your variables such)

# imports
import sys # module to interface our program with the operation system

#constants can go here


#functions can go here
def even_or_odd(x=0): # if not specified, x should take value 0
	
	"""Find whether a number x is even or odd."""
	if x % 2 == 0: #The conditional if
		return "%d is Even!" % x
	return "%d is Odd!" %x
	
def largest_divisor_five(x=120):
	"""Find which is the largest divisor of x among 2,3,4,5."""
	largest = 0
	if x % 5 == 0:
			largest = 5
	elif x % 4 == 0: #means "else, if"
		largest = 4
	elif x % 3 == 0:
		largest = 3
	elif x % 2 == 2:
		largest = 2
	else: # When all other (if, elif) conditions are not meet
			return "No divisor found for %d!" % x # Each function can return a value or a return 
			#variable
	return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
	"""Find whether an integer is prime."""
	for i in range(2, x):# "range returns a sequence of integers
			if x % i == 0:
				print "%d is not a prime: %d is a divisor" % (x, i) # Print formatted text "%d(return) %s %f %e" % (20,"30",0.0003,0.00003)
				
				return False
			print "%d is a prime!" % x
			return True

def find_all_primes(x=22):
	"""Find all the primes up to x"""
	allprimes = []
	for i in range(2, x + 1):
		if is_prime(i):
			allprimes.append (i)
	print "There are %d primes between 2 and %d" % (len(allprimes), x)
	return allprimes

def main(argv):
	# sys.exit
	print even_or_odd(22)
	print even_or_odd(33)
	print largest_divisor_five(120)
	print largest_divisor_five(121)
	print is_prime(60)
	print is_prime(59)
	print find_all_primes(100)
	return 0
	
if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)
			
																		



if (__name__ == "__main__"): #makes sure the main function is called from commandline
		status = main(sys.argv) #"Argument Variable". --argv is a var. that holds arguments you pass to python script. sys.argv is an object created by python using the sys module, containing names of the argument variables in current script. 
		sys.exit(status) #Control Statement - Way to exit in "a dignified and abrupt manner
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is a prime!
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is a prime!
16 is not a prime: 2 is a divisor
17 is a prime!
18 is not
**********************************************************************

Code ran without errors

Time consumed = 0.01452s

======================================================================
Inspecting script file cfexcercises.py...

File contents are:
**********************************************************************
#!/user/bin/env python

"""cfexcercises - some numeric manipulation using 'foo' commands

foo1(x) -> Finds x to the power of 0.5
foo2(x, y) -> Prints the highest value
foo3(x, y, z) -> Swaps x and y, in string position, should x > y. Then swaps y and z, should y > z (in this last operation, if x > y initially swap, y = initial 'x' value. Then prints new integer order.
foo4(x) -> Multiplies x by all integers from 1 to x inclusive
foo5(x) -> Returns x(x-1)"""

__author___="'Tom Davy, t.davy17@imperial.ac.uk'"
__version__="'0.01'"
__date__="'10/10/17'"

#imports

import sys

# How many times will 'hello' be printed?
# 1)
for i in range(3, 17):
	print 'hello'
# 2)
for j in range (12):
	if j % 3 == 0:
		print 'hello'
		
# 3)
	for j in range(15):
		if j % 5 == 3:
			print 'hello'
		elif j % 4 == 3:
			print 'hello'
	
#4)
z = 0
while z !=15:
	print 'hello'
	z = z + 3  #Useful for parsing csv etc.
	
#5) 
z = 12
while z < 100:
	if z == 31:
		for k in range(7):
			print 'hello'
	elif z == 18:
			print 'hello'
	z = z + 1


#What does fooXX do?
def foo1(x):
	return x ** 0.5
	
def foo2(x, y):
		if x > y:
			return x
		return y

def foo3(x, y, z): #Given 3 values; Prints value y in pos x
		if x > y:
			tmp = y
			y = x
			x = tmp
		if y > z:
			tmp = z
			z = y
			y = tmp
		return [x, y, z]

def foo4(x):
		result = 1
		for i in range(1, x + 1):
			result = result * i
		return result

	#This is a recursive function, meaning that the functional calls itself
	#Read about it at
	#en.wikipedia.org/wiki/Recursion_(computer_science)
def foo5(x):
		if x == 1:
			return 1
		return x * foo5(x - 1)
		
def main(argv):
	print foo1(42)
	print foo2(43, 42)
	print foo3(24, 16, 8) # >> 16, 8, 24. 
	print foo4(6)
	print foo5(7)
	return 0

if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)
			
		
**********************************************************************

Testing cfexcercises.py...

cfexcercises.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Missing docstrings in one more functions!
.5 pt deducted per missing docstring

Current Marks = 83.0

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hel
**********************************************************************

Code ran without errors

Time consumed = 0.01102s

======================================================================
Inspecting script file ToDo.txt...

File contents are:
**********************************************************************
Write docstrings for test_oaks.py
**********************************************************************

Testing ToDo.txt...

======================================================================
======================================================================
Finished running scripts

Ran into 4 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Marks for the Week = 83.0

NOTE THAT THESE ARE NOT THE FINAL MARKS FOR THE WEEK, BUT AN UPPER BOUND ON THE MARKS!